/*==============================================================================================================================
| Author        Ignia, LLC
| Client        Ignia, LLC
| Project       Topics Library
\=============================================================================================================================*/
using OnTopic.Collections.Specialized;
using OnTopic.Repositories;

namespace OnTopic.Attributes {

  /*============================================================================================================================
  | CLASS: ATTRIBUTE COLLECTION
  \---------------------------------------------------------------------------------------------------------------------------*/
  /// <summary>
  ///   Represents a collection of <see cref="AttributeRecord"/> objects.
  /// </summary>
  /// <remarks>
  ///   <see cref="AttributeRecord"/> objects represent individual instances of attributes associated with particular topics.
  ///   The <see cref="Topic"/> class tracks these through its <see cref="Topic.Attributes"/> property, which is an instance of
  ///   the <see cref="AttributeCollection"/> class.
  /// </remarks>
  public class AttributeCollection : TrackedRecordCollection<AttributeRecord, string, AttributeSetterAttribute> {

    /*==========================================================================================================================
    | PRIVATE VARIABLES
    \-------------------------------------------------------------------------------------------------------------------------*/
    private static readonly     List<string>                    _excludedAttributes             = new() {
      nameof(Topic.Title),
      nameof(Topic.LastModified)
    };

    /*==========================================================================================================================
    | CONSTRUCTOR
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <summary>
    ///   Initializes a new instance of the <see cref="AttributeCollection"/> class.
    /// </summary>
    /// <remarks>
    ///   The <see cref="AttributeCollection"/> is intended exclusively for providing access to attributes via the <see cref="
    ///   Topic.Attributes"/> property. For this reason, the constructor is marked as internal.
    /// </remarks>
    /// <param name="parentTopic">A reference to the topic that the current attribute collection is bound to.</param>
    internal AttributeCollection(Topic parentTopic) : base(parentTopic) {
    }

    /*==========================================================================================================================
    | PROPERTY: PARENT COLLECTION
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <inheritdoc/>
    protected override TrackedRecordCollection<AttributeRecord, string, AttributeSetterAttribute>? ParentCollection =>
      AssociatedTopic.Parent?.Attributes;

    /*==========================================================================================================================
    | PROPERTY: BASE COLLECTION
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <inheritdoc/>
    protected override TrackedRecordCollection<AttributeRecord, string, AttributeSetterAttribute>? BaseCollection =>
      AssociatedTopic.BaseTopic?.Attributes;

    /*==========================================================================================================================
    | METHOD: IS DIRTY
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <summary>
    ///   Determine if <i>any</i> attributes in the <see cref="AttributeCollection"/> are dirty.
    /// </summary>
    /// <remarks>
    ///   This method is intended primarily for data storage providers, such as <see cref="ITopicRepository"/>, which may need
    ///   to determine if any attributes are dirty prior to saving them to the data storage medium. Be aware that this does
    ///   <i>not</i> track whether any <see cref="Topic.Relationships"/> have been modified; as such, it may still be necessary
    ///   to persist changes to the storage medium.
    /// </remarks>
    /// <param name="excludeLastModified">
    ///   Optionally excludes <see cref="AttributeRecord"/>s whose keys start with <c>LastModified</c>. This is useful for
    ///   excluding the byline (<c>LastModifiedBy</c>) and dateline (<c>LastModified</c>) since these values are automatically
    ///   generated by e.g. the OnTopic Editor and, thus, may be irrelevant updates if no other attribute values have changed.
    /// </param>
    /// <returns>True if the attribute value is marked as dirty; otherwise false.</returns>
    public bool IsDirty(bool excludeLastModified)
      => DeletedItems.Count > 0 || Items.Any(a =>
        a.IsDirty &&
        (!excludeLastModified || !a.Key.StartsWith("LastModified", StringComparison.OrdinalIgnoreCase))
      );

    /*==========================================================================================================================
    | METHOD: SET VALUE
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <summary>
    ///   Helper method that either adds a new <see cref="AttributeRecord"/> object or updates the value of an existing one,
    ///   depending on whether that value already exists.
    /// </summary>
    /// <remarks>
    ///   Minimizes the need for defensive conditions throughout the library.
    /// </remarks>
    /// <param name="key">The string identifier for the <see cref="AttributeRecord"/>.</param>
    /// <param name="value">The text value for the <see cref="AttributeRecord"/>.</param>
    /// <param name="markDirty">
    ///   Specified whether the value should be marked as <see cref="TrackedRecord{T}.IsDirty"/>. By default, it will be marked
    ///   as dirty if the value is new or has changed from a previous value. By setting this parameter, that behavior is
    ///   overwritten to accept whatever value is submitted. This can be used, for instance, to prevent an update from being
    ///   persisted to the data store on <see cref="Repositories.ITopicRepository.Save(Topic, Boolean)"/>.
    /// </param>
    /// <param name="version">
    ///   The <see cref="DateTime"/> value that the attribute was last modified. This is intended exclusively for use when
    ///   populating the topic graph from a persistent data store as a means of indicating the current version for each
    ///   attribute. This is used when e.g. importing values to determine if the existing value is newer than the source value.
    /// </param>
    /// <param name="isExtendedAttribute">Determines if the attribute originated from an extended attributes data store.</param>
    /// <requires
    ///   description="The key must be specified for the AttributeRecord key/value pair."
    ///   exception="T:System.ArgumentNullException">
    ///   !String.IsNullOrWhiteSpace(key)
    /// </requires>
    /// <requires
    ///   description="The value must be specified for the AttributeRecord key/value pair."
    ///   exception="T:System.ArgumentNullException">
    ///   !String.IsNullOrWhiteSpace(value)
    /// </requires>
    /// <requires
    ///   description="The key should be an alphanumeric sequence; it should not contain spaces or symbols"
    ///   exception="T:System.ArgumentException">
    ///   !value.Contains(" ")
    /// </requires>
    public void SetValue(
      string key,
      string? value,
      bool? markDirty = null,
      DateTime? version = null,
      bool? isExtendedAttribute = null
    ) {
      base.SetValue(key, value, markDirty, version);
      if (Contains(key)) {
        var attributeValue      = this[key];
        var attributeIndex      = IndexOf(attributeValue);
        if (isExtendedAttribute is not null && isExtendedAttribute != attributeValue.IsExtendedAttribute) {
          attributeValue        = attributeValue with {
            IsExtendedAttribute = isExtendedAttribute
          };
          base[attributeIndex]  = attributeValue;
        }
      }
    }

    /*==========================================================================================================================
    | METHOD: AS ATTRIBUTE DICTIONARY
    \-------------------------------------------------------------------------------------------------------------------------*/
    /// <summary>
    ///   Gets an <see cref="AttributeValueDictionary"/> based on the <see cref="Topic.Attributes"/> of the current <see cref="
    ///   AttributeCollection"/>. Optionall includes attributes from any <see cref="Topic.BaseTopic"/>s that the <see cref="
    ///   TrackedRecordCollection{TItem, TValue, TAttribute}.AssociatedTopic"/> derives from.
    /// </summary>
    /// <remarks>
    ///   The <see cref="AsAttributeDictionary(Boolean)"/> method will exclude attributes which correspond to properties on
    ///   <see cref="Topic"/> which contain specialized getter logic, such as <see cref="Topic.Title"/> and <see cref="Topic.
    ///   LastModified"/>.
    /// </remarks>
    /// <param name="inheritFromBase">
    ///   Determines if attributes from the <see cref="Topic.BaseTopic"/> should be included. Defaults to <c>false</c>.
    /// </param>
    /// <returns>A new <see cref="AttributeValueDictionary"/> containing attributes</returns>
    public AttributeValueDictionary AsAttributeDictionary(bool inheritFromBase = false) {
      var sourceAttributes      = (AttributeCollection?)this;
      var attributes            = new AttributeValueDictionary();
      var count                 = 0;
      while (sourceAttributes is not null && ++count < 5) {
        foreach (var attribute in sourceAttributes) {
          if (count is 1 || !attributes.ContainsKey(attribute.Key)) {
            attributes.TryAdd(attribute.Key, attribute.Value);
          }
        }
        sourceAttributes = inheritFromBase? sourceAttributes.AssociatedTopic.BaseTopic?.Attributes : null;
      }
      foreach (var attribute in _excludedAttributes) {
        attributes.Remove(attribute);
      }
      return attributes;
    }

  } //Class
} //Namespace